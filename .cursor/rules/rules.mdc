---
description: Comprehensive ruleset for NodeInDepth project covering project organization, code standards, documentation requirements, contribution guidelines, and learning paths. This ruleset is mandatory and must be followed for all contributions.
alwaysApply: true
---

# NodeInDepth Project Ruleset

## ⚠️ CRITICAL: Always Follow This Ruleset

**MANDATORY**: This ruleset is the authoritative guide for the NodeInDepth project. All contributors, maintainers, developers, and AI assistants working on this project **MUST** follow these rules without exception.

### Ruleset Compliance Requirements

- ✅ **Read First**: Before making any changes, read this entire ruleset
- ✅ **Follow Always**: All rules in this document are mandatory, not suggestions
- ✅ **Reference Frequently**: When in doubt, refer back to this ruleset
- ✅ **Update When Needed**: If you discover gaps or inconsistencies, update this ruleset
- ✅ **Enforce Consistently**: All code, documentation, and contributions must comply

**Failure to follow this ruleset will result in contributions being rejected or requiring revision.**

## Summary of Key Rules

### Must-Do's

1. ✅ **Read this entire ruleset before contributing**
2. ✅ **Follow all ruleset requirements without exception**
3. ✅ One folder per core concept
4. ✅ README.md in every concept folder with **prerequisites section** linking to fundamentals
5. ✅ Use `node:` protocol for core modules
6. ✅ Use ES modules (`import/export`)
7. ✅ **Add cross-references** to fundamentals in code comments and README
8. ✅ Explain "why" in comments, not just "what"
9. ✅ Mark unsafe operations with warnings
10. ✅ Include extensive problem statements in documentation
11. ✅ Test all code examples before committing (basic → enterprise)
12. ✅ Update main README when adding content
13. ✅ Follow version requirements strictly
14. ✅ **Complete all TODOs** or document why they remain
15. ✅ **Include enterprise-level production examples** in each concept folder
16. ✅ **Update fundamentals docs** with "Used In" sections when adding concepts

### Must-Not-Do's

1. ❌ **Don't ignore or bypass this ruleset** - it is mandatory
2. ❌ **Don't contribute without reading the ruleset first**
3. ❌ Don't use CommonJS (`require/module.exports`)
4. ❌ Don't import core modules without `node:` prefix
5. ❌ Don't commit non-executable code examples
6. ❌ Don't skip README files in concept folders
7. ❌ Don't skip prerequisites sections in READMEs
8. ❌ Don't add code without cross-references to fundamentals
9. ❌ Don't ignore version requirements
10. ❌ Don't add content without updating main README
11. ❌ Don't use vague or unclear comments
12. ❌ Don't skip safety warnings for unsafe operations
13. ❌ Don't add concepts without enterprise-level examples
14. ❌ Don't hardcode specific concepts in generic sections of the ruleset

---

## Table of Contents

1. [Project Purpose & Philosophy](#project-purpose--philosophy)
2. [Project Organization](#project-organization)
3. [Content Areas](#content-areas)
4. [Code Example Standards](#code-example-standards)
5. [Documentation Standards](#documentation-standards)
6. [Configuration Requirements](#configuration-requirements)
7. [Learning Path](#learning-path)
8. [Contribution Guidelines](#contribution-guidelines)
9. [Ruleset Maintenance](#ruleset-maintenance)

---

## Project Purpose & Philosophy

### Mission

**NodeInDepth** is a comprehensive educational resource designed to help developers understand Node.js from the ground up. This project focuses on **in-depth analysis** of core Node.js concepts and computing fundamentals, moving beyond surface-level explanations to explore the underlying mechanisms, historical context, and practical applications.

### Core Principles

1. **Educational Focus**: Every piece of content serves the primary goal of teaching and understanding
2. **Depth Over Breadth**: Prefer thorough explanations over quick summaries
3. **Beginner-Friendly**: Start with foundational concepts and build complexity progressively
4. **Practical Examples**: All concepts are demonstrated through executable code examples
5. **Historical Context**: Explain the "why" behind concepts, not just the "how"
6. **Problem-Solution Approach**: Each concept begins with the problem it solves

### Learning Philosophy

- **Theory First**: Understand the problem and solution conceptually before implementation
- **Practice Second**: Reinforce understanding through hands-on code examples
- **Progressive Complexity**: Each topic builds on previous knowledge
- **Self-Directed**: Learners can follow their own pace while maintaining a recommended path

---

## Project Organization

### Folder Structure

```
NodeInDepth/
├── docs/                    # General documentation and guides
│   ├── getting-started.md   # Setup and prerequisites
│   ├── configuration-files.md  # Configuration explanations
│   └── fundamentals/        # Foundational concepts
│       ├── README.md        # Fundamentals overview
│       ├── binary-data.md   # Bits, bytes, number systems
│       ├── memory.md        # Memory concepts
│       ├── async-programming.md  # Async patterns
│       └── file-systems.md  # File system basics
├── buffers/                 # Buffer concept folder
│   ├── README.md           # Concept explanation
│   ├── app.js              # Main examples
│   └── production-example.js # Enterprise examples
├── emitters/               # EventEmitter concept folder
│   ├── README.md           # Concept explanation
│   ├── app.js              # Examples
│   └── production-example.js # Enterprise examples
├── file-system/            # File System concept folder
│   ├── README.md           # Concept explanation
│   ├── app.js              # Async examples
│   ├── fs-types.js         # Sync examples
│   └── fs-project/         # Project examples
├── package.json            # Project configuration
├── .nvmrc                  # Node.js version specification
├── .npmrc                  # npm configuration
└── README.md               # Project overview
```

### Naming Conventions

#### Folders

- **Format**: lowercase, plural nouns
- **Examples**: `buffers/`, `emitters/`, `streams/`, `modules/`
- **Rationale**: Represents the concept category, not a specific instance

#### Code Files

- **Format**: descriptive, kebab-case or camelCase
- **Examples**: `app.js`, `different-alloc.js`, `event-handler.js`
- **Rationale**: Clearly indicate the file's purpose

#### Documentation Files

- **Format**: kebab-case with `.md` extension
- **Examples**: `getting-started.md`, `configuration-files.md`
- **Rationale**: Consistent with markdown documentation standards

### Required Files Per Concept Folder

Each concept folder (e.g., `buffers/`, `emitters/`) **MUST** include:

1. **README.md**: Comprehensive explanation of the concept

   - Problem statement that led to the concept
   - Solution explanation
   - Historical context (when relevant)
   - Links to related concepts
   - TODO markers for future expansion

2. **app.js** (or similar): Main executable examples demonstrating the concept

   - Well-commented code
   - Progressive examples (simple to complex)
   - Expected output descriptions

3. **Additional files**: Optional files for specific subtopics
   - Named descriptively (e.g., `different-alloc.js` for buffer allocation strategies)

### Project Structure Visualization

```mermaid
graph TD
    A[NodeInDepth Root] --> B[docs/]
    A --> C[Concept Folders]
    A --> D[Config Files]

    B --> B1[getting-started.md]
    B --> B2[configuration-files.md]
    B --> B3[fundamentals/]

    B3 --> B3A[README.md]
    B3 --> B3B[binary-data.md]
    B3 --> B3C[memory.md]
    B3 --> B3D[async-programming.md]
    B3 --> B3E[file-systems.md]

    C --> C1[buffers/]
    C --> C2[emitters/]
    C --> C3[file-system/]
    C --> C4[Future Concepts]

    C1 --> C1A[README.md]
    C1 --> C1B[app.js]
    C1 --> C1C[production-example.js]

    C2 --> C2A[README.md]
    C2 --> C2B[app.js]
    C2 --> C2C[production-example.js]

    D --> D1[package.json]
    D --> D2[.nvmrc]
    D --> D3[.npmrc]

    style A fill:#e1f5ff
    style C fill:#fff4e1
    style B fill:#e8f5e9
    style B3 fill:#fff9c4
    style D fill:#fce4ec
```

---

## Content Areas

### Topic Organization

Content areas are organized into:

- **Concept Folders**: Core Node.js topics (buffers, emitters, file-system, etc.)
- **Fundamentals**: Foundational concepts in `docs/fundamentals/` (binary-data, memory, async-programming, file-systems)

### Concept Folder Structure

Each concept folder follows this pattern:

```
concept-name/
├── README.md           # With prerequisites section linking to fundamentals
├── app.js              # Main examples with cross-references
├── production-example.js # Enterprise-level examples
└── [other-files].js   # Additional subtopic examples
```

### Fundamentals Structure

Foundational concepts are documented in `docs/fundamentals/`:

```
docs/fundamentals/
├── README.md           # Overview and learning path
├── binary-data.md      # Bits, bytes, number systems, endianness, encoding
├── memory.md           # Memory allocation, heap, GC, pools
├── async-programming.md # Callbacks, promises, event loop
└── file-systems.md     # File descriptors, I/O, blocking vs non-blocking
```

**Each fundamental doc MUST include**:

- Problem statement and solution explanation
- Comprehensive coverage of the concept
- "Used In" section linking to concept folders that use it
- "Related Concepts" section

### Content Requirements

Each content area **MUST** include:

1. **Prerequisites Section**: Links to required fundamentals (REQUIRED)
2. **Problem Statement**: What problem does this concept solve?
3. **Solution Explanation**: How does this concept address the problem?
4. **Historical Context**: Why was this needed? (when relevant)
5. **Code Examples**: Executable demonstrations with cross-references
6. **Cross-References**: Links to fundamentals and related concepts
7. **Enterprise Examples**: Production-ready patterns

### Fundamentals Documentation

**REQUIRED**: Foundational concepts are documented in `docs/fundamentals/`:

- **Structure**: Each fundamental has its own `.md` file
- **Index**: `docs/fundamentals/README.md` provides overview and learning path
- **Cross-References**: Each fundamental doc includes "Used In" section linking to concept folders
- **Coverage**: Fundamentals explain precursors needed for concept folders

**Current Fundamentals**:

- `binary-data.md`: Bits, bytes, number systems, endianness, character encoding
- `memory.md`: Memory allocation, heap, garbage collection, memory pools
- `async-programming.md`: Callbacks, promises, async/await, event loop deep dive
- `file-systems.md`: File descriptors, I/O operations, blocking vs non-blocking

**When Adding New Concepts**:

- Identify required fundamentals and ensure they're documented
- Add "Used In" sections to relevant fundamentals docs
- Link to fundamentals in code comments and README prerequisites

### Adding New Topics

When adding new topics:

1. **Identify Prerequisites**: Determine which fundamentals are needed
2. **Create Concept Folder**: Follow naming conventions (lowercase, plural)
3. **Write README.md**: Include prerequisites section, problem/solution, cross-references
4. **Add Code Examples**: Basic → intermediate → enterprise-level
5. **Add Cross-References**: Link to fundamentals in code comments and README
6. **Update Main README**: Add new topic to documentation list
7. **Update Fundamentals**: Add "Used In" references if new concept uses fundamentals

---

## Code Example Standards

### Executability

- **ALL** code examples must be executable without errors
- Test all examples before committing
- Include expected output in comments when helpful

### Code Style

#### Module Imports

**REQUIRED**: Always use the `node:` protocol prefix for core modules

```javascript
// ✅ CORRECT
import { Buffer } from 'node:buffer';
import EventEmitter from 'node:events';

// ❌ INCORRECT
import { Buffer } from 'buffer';
import EventEmitter from 'events';
```

**Rationale**: The `node:` protocol explicitly indicates core modules and prevents conflicts with npm packages.

#### ES Modules

**REQUIRED**: Use ES6 import/export syntax (project uses `"type": "module"`)

```javascript
// ✅ CORRECT
import { Buffer } from 'node:buffer';
export function myFunction() {}

// ❌ INCORRECT
const { Buffer } = require('node:buffer');
module.exports = {};
```

### Comment Standards

#### Inline Comments

Comments should explain **"why"** not just **"what"**, and include cross-references to fundamentals when introducing concepts:

```javascript
// ✅ GOOD - Explains why with cross-reference
// Memory allocation (see [Memory](../docs/fundamentals/memory.md) for details on heap allocation)
const buffer = Buffer.alloc(1024);

// Writing hex value (see [Binary Data](../docs/fundamentals/binary-data.md) for hex explanation)
memoryContainer[0] = 0xff;

// ❌ BAD - Only states what, no cross-reference
// Allocate buffer
const buffer = Buffer.alloc(1024);
```

#### Cross-Reference Requirements

**MANDATORY**: When introducing foundational concepts in code, add inline cross-references:

- **Binary/Hex/Decimal**: Link to `docs/fundamentals/binary-data.md`
- **Memory/Allocation/Heap**: Link to `docs/fundamentals/memory.md`
- **Callbacks/Promises/Async**: Link to `docs/fundamentals/async-programming.md`
- **File Descriptors/I/O**: Link to `docs/fundamentals/file-systems.md`
- **Related Concepts**: Link to other concept folders (e.g., `../buffers/`)

**Format**: `(see [Concept Name](../docs/fundamentals/concept.md) for details)`

#### Block Comments

Use block comments for:

- Multi-line explanations
- Historical context
- Complex algorithm explanations
- Cross-references to comprehensive documentation

### Safety Warnings

**REQUIRED**: Mark unsafe operations with clear warnings

```javascript
// ✅ GOOD - Clear warning
// NOTE: Do not execute with unsafeMaxBuffer uncommented, could crash the system if you do not have 4 GiB of memory available.
const unsafeMaxBuffer = Buffer.allocUnsafe(constants.MAX_LENGTH);
```

### Code Organization

1. **Progressive Examples**: Start with simple, build to complex
2. **Logical Grouping**: Group related examples together
3. **Clear Naming**: Use descriptive variable names
4. **Consistent Formatting**: Follow JavaScript best practices

### Example Progression Requirements

**MUST DO**: All concept folders must include examples that progress from basic to enterprise-level production standards:

#### Basic Examples (`app.js` or similar)

- Simple, single-concept demonstrations
- Clear, well-commented code
- Focus on understanding the core API
- Suitable for beginners

#### Intermediate Examples

- Combine multiple concepts
- Show common patterns and use cases
- Include error handling basics
- Demonstrate best practices

#### Advanced/Enterprise Examples

**REQUIRED**: Each concept folder should include at least one enterprise-level production example demonstrating:

- **Production-Ready Patterns**: Error handling, logging, monitoring
- **Performance Optimization**: Efficient algorithms, memory management
- **Security Best Practices**: Input validation, secure defaults
- **Scalability Considerations**: Handling high load, resource management
- **Real-World Scenarios**: Practical use cases from actual applications
- **Code Quality**: Clean architecture, separation of concerns, testability
- **Documentation**: Comprehensive comments explaining architectural decisions

**File Naming**: Use descriptive names like `production-example.js`, `enterprise-pattern.js`, or `advanced-usage.js`

**Example Structure**:

```javascript
// Enterprise-level example: High-performance buffer processing
// This example demonstrates production patterns for processing large data streams
// Features: Error handling, memory management, performance monitoring

import { Buffer } from 'node:buffer';
import { performance } from 'node:perf_hooks';

/**
 * Production-grade buffer processor with:
 * - Memory-efficient streaming
 * - Error recovery
 * - Performance monitoring
 * - Resource cleanup
 */
class ProductionBufferProcessor {
  // ... enterprise-level implementation
}
```

**Rationale**: Enterprise examples bridge the gap between learning and real-world application, showing how concepts are used in production environments.

### Example Structure

```javascript
// 1. Import statements
import { Buffer } from 'node:buffer';

// 2. Basic example with explanation and cross-reference
// Memory allocation (see [Memory](../docs/fundamentals/memory.md) for details)
const memoryContainer = Buffer.alloc(4); // 4 Bytes

// 3. Operations with comments and cross-references
// Writing hex value (see [Binary Data](../docs/fundamentals/binary-data.md) for hex explanation)
memoryContainer[0] = 0xff;

// 4. Output demonstration
console.log(memoryContainer.toString('hex'));

// 5. Advanced example
// ... more complex usage
```

---

## Documentation Standards

### README Files

Each concept folder **MUST** have a `README.md` that follows this structure:

#### 1. Title and Brief Description

```markdown
# Concept Name : Explained

### The problem that [concept] solves
```

#### 2. Prerequisites Section (REQUIRED)

```markdown
## Prerequisites

Before studying this concept, it's recommended to understand:

- **[Fundamental Name](../docs/fundamentals/fundamental.md)**: Brief description
- **[Another Fundamental](../docs/fundamentals/another.md)**: Brief description

See [Fundamentals](../docs/fundamentals/) for complete list of foundational concepts.
```

#### 3. Problem Statement

Explain the fundamental problem(s) with inline cross-references to fundamentals:

```markdown
Early computers ran into 3 stubborn realities:

1. Different speeds everywhere (see [Memory](../docs/fundamentals/memory.md) for speed differences)
2. Devices don't speak in neat chunks
3. Stopping CPUs is expensive
```

#### 4. Solution Explanation

Explain how the concept solves the problem with cross-references:

```markdown
> Buffers were invented to decouple timing.

Buffer is a region of memory (see [Memory](../docs/fundamentals/memory.md)) used to store data temporarily...
```

#### 5. Code References

Link to code examples in the same folder:

```markdown
See [app.js](app.js) for basic examples.
See [production-example.js](production-example.js) for enterprise patterns.
```

#### 6. Cross-References Section

```markdown
## Cross-References

- **[Related Concept](../related-concept/)**: How concepts relate
- **[Fundamentals](../docs/fundamentals/)**: Foundational concepts used
```

**MUST DO - TODO Completion**:

When working on a concept folder:

1. **Review All TODOs**: Check README.md and all code files for TODO markers
2. **Prioritize Completion**: Address TODOs systematically
3. **Extensive Documentation**: Add detailed explanations, examples, use cases, pitfalls, performance considerations
4. **Add Cross-References**: Include links to fundamentals when completing TODOs
5. **Remove Completed TODOs**: Replace with comprehensive content
6. **Document Remaining TODOs**: If cannot complete, explain why and timeline

### Main README.md

The root `README.md` should:

1. **Project Overview**: What is this project?
2. **Learning Objectives**: What will you learn?
3. **Documentation Links**: Links to all documentation
4. **Usage Instructions**: How to use this resource
5. **Prerequisites**: What you need to know
6. **Contributing**: How to contribute (brief)

**MUST DO - Extensive README Content**:

When creating or updating README.md files:

1. **Prerequisites Section**: List required fundamentals with links (see structure above)
2. **Comprehensive Coverage**: Detailed problem statements, solutions, historical context
3. **Inline Cross-References**: Link to fundamentals when concepts are introduced
4. **Code References**: Link to all code examples in the folder
5. **Cross-References Section**: Link to related concepts and fundamentals
6. **Learning Path**: Prerequisites, what this enables, recommended next steps

### Documentation Style

- **Tone**: Educational, clear, beginner-friendly
- **Format**: Markdown with proper headings hierarchy
- **Links**: Use relative paths for internal links
- **Code Blocks**: Always specify language (e.g., ` ```javascript `)
- **Examples**: Include both code and expected output when helpful

### Cross-Referencing

**REQUIRED**: Extensive cross-referencing between concept folders and fundamentals:

#### In Code Files

Add inline cross-references when introducing foundational concepts:

```javascript
// Writing hex values (see [Binary Data](../docs/fundamentals/binary-data.md) for hex explanation)
memoryContainer[0] = 0xff;

// async/await pattern (see [Asynchronous Programming](../docs/fundamentals/async-programming.md) for async patterns)
async function readFile() {
  const data = await fs.readFile('file.txt');
}
```

#### In README Files

**Prerequisites Section** (required at top of each concept README):

```markdown
## Prerequisites

Before studying this concept, it's recommended to understand:

- **[Binary Data](../docs/fundamentals/binary-data.md)**: Bits, bytes, number systems
- **[Memory](../docs/fundamentals/memory.md)**: Memory allocation, heap, garbage collection

See [Fundamentals](../docs/fundamentals/) for complete list of foundational concepts.
```

**Inline Cross-References** throughout README:

```markdown
Buffers work with binary data (see [Binary Data](../docs/fundamentals/binary-data.md) for fundamentals).

Memory is allocated on the heap (see [Memory](../docs/fundamentals/memory.md) for details).
```

#### In Fundamentals Docs

**"Used In" Section** (required at end of each fundamental doc):

```markdown
## Used In

This fundamental concept is used in:

- **[Buffers](../buffers/)**: Binary data handling, hex encoding, number systems
- **[File System](../file-system/)**: Binary file operations, encoding conversions
```

**Cross-Reference Mapping**:

- Concept folders → Link to relevant fundamentals when concepts are introduced
- Fundamentals docs → Link back to concept folders that use them
- Code comments → Link to fundamentals when foundational concepts appear

---

## Configuration Requirements

### Node.js Version

**REQUIRED**: Node.js 24.12.0 (LTS)

- Specified in [.nvmrc](.nvmrc)
- Enforced via `engines` field in [package.json](package.json)
- Strict enforcement via `engine-strict=true` in [.npmrc](.npmrc)

**Rationale**: Ensures consistency across development environments and prevents version-related bugs.

### npm Version

**REQUIRED**: npm 11.7.0

- Specified in `engines` field in [package.json](package.json)
- Enforced via `engine-strict=true` in [.npmrc](.npmrc)

### Module System

**REQUIRED**: ES Modules

- `"type": "module"` in [package.json](package.json)
- All code must use `import/export` syntax
- Core modules must use `node:` protocol prefix

### Configuration Files

#### .nvmrc

**Purpose**: Specifies Node.js version for version managers

**Content**: Single version number (e.g., `24.12.0`)

**Usage**: `nvm use` (or equivalent for other version managers)

#### .npmrc

**Purpose**: Configures npm behavior for this project

**Current Setting**: `engine-strict=true`

**Effect**: npm will refuse to install if Node.js/npm versions don't match `engines` field

#### package.json

**Required Fields**:

- `name`: Project name
- `version`: Project version
- `type`: Must be `"module"`
- `engines`: Node.js and npm version requirements
- `description`: Project description

### Version Management Workflow

1. **On Clone**: Run `nvm use` to switch to project version
2. **On Install**: npm checks versions automatically (fails if mismatch)
3. **On Update**: Update `.nvmrc` and `package.json` engines together

---

## Learning Path

### Recommended Order

Follow this sequence for optimal learning:

```mermaid
graph LR
    A[Start] --> B[Getting Started]
    B --> C[Configuration Files]
    C --> D[Core Concepts]
    D --> E[Advanced Concepts]
    E --> F[Enterprise Patterns]

    B --> B1[Setup Environment]
    B --> B2[Install Node.js]
    B --> B3[Configure Git]

    C --> C1[Understand .nvmrc]
    C --> C2[Understand .npmrc]

    D --> D1[Read README]
    D --> D2[Study Basic Examples]
    D --> D3[Run and Experiment]

    E --> E1[Study Advanced Examples]
    E --> E2[Understand Patterns]
    E --> E3[Build Applications]

    F --> F1[Study Enterprise Examples]
    F --> F2[Production Patterns]
    F --> F3[Real-World Scenarios]

    style A fill:#e1f5ff
    style B fill:#e8f5e9
    style C fill:#fff4e1
    style D fill:#f3e5f5
    style E fill:#e0f2f1
    style F fill:#fff9c4
```

**Note**: This diagram shows the generic learning progression. Specific concepts and their order are determined by prerequisites and documented in the main README.md.

### Step-by-Step Path

**Note**: This section provides a generic learning path structure. The specific topics and order should be determined by:

1. Prerequisites and dependencies between concepts
2. Complexity progression (simple to advanced)
3. Practical application needs

#### Phase 1: Setup (Required)

1. **Read**: [docs/getting-started.md](../docs/getting-started.md)

   - Install Node.js (use version manager)
   - Configure Git
   - Set up code editor

2. **Read**: [docs/configuration-files.md](../docs/configuration-files.md)
   - Understand `.nvmrc` and `.npmrc`
   - Set up version management
   - Verify configuration

#### Phase 2: Fundamentals (Before Concepts)

3. **Study Fundamentals** (before diving into concepts):
   - Review [Fundamentals](../docs/fundamentals/) overview
   - Study relevant fundamentals based on concept you want to learn:
     - For Buffers: [Binary Data](../docs/fundamentals/binary-data.md) + [Memory](../docs/fundamentals/memory.md)
     - For EventEmitter: [Asynchronous Programming](../docs/fundamentals/async-programming.md)
     - For File System: [File Systems](../docs/fundamentals/file-systems.md) + [Asynchronous Programming](../docs/fundamentals/async-programming.md)

#### Phase 3: Core Concepts (Sequential)

4. **Study Concept Folders** (order determined by prerequisites and complexity):
   - Read prerequisites section in README.md
   - Review required fundamentals if not already studied
   - Read the concept's README.md for theory and problem statement
   - Study basic examples (typically `app.js`) for core operations
   - Explore advanced examples for deeper understanding
   - Study enterprise-level examples for production patterns
   - Run examples and experiment
   - Follow cross-references to fundamentals when concepts are unclear

**Generic Study Pattern for Each Concept**:

1. Check prerequisites section in README.md
2. Review required fundamentals if needed
3. Read README.md thoroughly (theory first)
4. Study basic examples (understand core API)
5. Run and modify basic examples
6. Study enterprise examples (production patterns)
7. Build your own examples
8. Review related concepts via cross-references

**Important**: The specific concepts and their order are documented in the main README.md. This ruleset provides the **framework** for learning, not the specific content order.

### Learning Principles

- **Don't Skip Steps**: Each phase builds on previous knowledge
- **Practice Actively**: Type code, don't just read
- **Experiment**: Modify examples to see what happens
- **Take Notes**: Document your understanding
- **Ask Questions**: Use TODOs as prompts for deeper exploration

---

## Contribution Guidelines

### ⚠️ Ruleset Compliance Required

**MANDATORY**: Before contributing to this project, you **MUST**:

1. **Read This Entire Ruleset**: Understand all sections before making changes
2. **Follow All Rules**: Every rule in this document is mandatory
3. **Reference During Work**: Keep this ruleset open and refer to it frequently
4. **Verify Compliance**: Before submitting, verify your contribution follows all rules
5. **Update Ruleset If Needed**: If you discover gaps, update the ruleset first

**All contributions will be reviewed against this ruleset. Non-compliant contributions will be rejected or require revision.**

### Adding New Concepts

When adding a new core concept (e.g., `streams/`, `modules/`):

**First Step**: Review this entire ruleset to ensure you understand all requirements.

#### 1. Create Folder Structure

```bash
mkdir streams
cd streams
touch README.md app.js
```

#### 2. Write README.md

Follow the [Documentation Standards](#documentation-standards) section:

- **Prerequisites section** (REQUIRED) - List fundamentals needed
- Problem statement with inline cross-references
- Solution explanation
- Historical context
- Code references
- Cross-references section

#### 3. Write Code Examples

Follow the [Code Example Standards](#code-example-standards) section:

- Use `node:` protocol
- ES modules syntax
- Comprehensive comments with cross-references to fundamentals
- Safety warnings for unsafe operations
- Progressive examples (basic → enterprise)
- Inline cross-references when introducing foundational concepts

#### 4. Update Main README

Add entry to main [README.md](README.md):

```markdown
## What You'll Learn

- **Core Concepts**: Event loop, asynchronous programming, module system, streams, and buffers
- **Streams**: Data flow and processing (NEW)
```

#### 5. Complete TODOs

**MUST DO**: Before considering a concept folder complete:

- Review all TODO markers in README.md and code files
- Complete or extensively document each TODO
- Add comprehensive explanations where TODOs indicated missing information
- Remove completed TODOs, replace with full content
- Document any TODOs that remain with explanation and timeline

#### 6. Add Extensive Documentation

**MUST DO**: Ensure README.md includes:

- **Prerequisites section** with links to fundamentals (REQUIRED)
- Extensive problem statement with historical context
- Comprehensive solution explanation
- Inline cross-references to fundamentals throughout
- Multiple examples (basic to enterprise-level)
- Real-world use cases
- Performance and security considerations
- Cross-references section linking to related concepts

#### 7. Create Enterprise Examples

**MUST DO**: Include at least one enterprise-level production example:

- Production-ready error handling
- Performance optimization patterns
- Security best practices
- Scalability considerations
- Real-world scenarios
- Clean architecture principles
- Comprehensive documentation

#### 8. Test Everything

- Run all code examples (basic, intermediate, enterprise)
- Verify no errors
- Check documentation links
- Ensure consistency with existing style
- Verify enterprise examples demonstrate production patterns

#### 9. Add Cross-References

**MUST DO**: Add cross-references throughout:

- **Code files**: Inline cross-references when introducing foundational concepts
- **README.md**: Prerequisites section, inline links, cross-references section
- **Fundamentals docs**: Update "Used In" sections to include new concept

#### 10. Update Ruleset

**MUST DO**: When adding a new concept section, update this ruleset:

- Add the new concept to the Learning Path section if it affects recommended order
- Update any examples that reference specific concepts to be more generic
- Ensure the ruleset remains accurate and reflects current project structure

### Modifying Existing Content

When updating existing content:

1. **Maintain Style**: Follow existing documentation and code style
2. **Update TODOs**: Remove TODO markers when addressed, add new ones as needed
3. **Cross-Reference**: Update links if structure changes
4. **Test**: Ensure all examples still work

### Code Review Checklist

Before submitting contributions:

- [ ] **Read and understood this entire ruleset**
- [ ] **Verified compliance with all ruleset requirements**
- [ ] All code examples are executable
- [ ] README includes prerequisites section with fundamentals links
- [ ] Code includes inline cross-references to fundamentals
- [ ] README includes inline cross-references throughout
- [ ] Code uses `node:` protocol for core modules
- [ ] Code uses ES modules syntax
- [ ] Comments explain "why" not just "what"
- [ ] Unsafe operations have warnings
- [ ] Main README updated with new content
- [ ] Cross-references are accurate and tested
- [ ] Enterprise-level examples included (if adding new concept)
- [ ] Fundamentals docs updated with "Used In" sections (if applicable)

### Documentation Updates

When updating documentation:

1. **Accuracy**: Verify all information is correct
2. **Completeness**: Address all aspects of the topic
3. **Clarity**: Use clear, beginner-friendly language
4. **Cross-References**: Add/update links to fundamentals and related concepts
5. **Examples**: Include practical examples
6. **Links**: Ensure all links work (test relative paths)

### Version Updates

When updating Node.js or npm versions:

1. Update [.nvmrc](.nvmrc)
2. Update `engines` in [package.json](package.json)
3. Test all examples with new version
4. Update documentation if behavior changes
5. Document breaking changes

---

## Ruleset Maintenance

### Updating This Ruleset

**MUST DO**: When adding new concept sections or making significant structural changes:

1. **Update Learning Path Section**:

   - Add new concepts to the recommended order if they affect learning sequence
   - Update the mermaid diagram if the learning flow changes
   - Document prerequisites and dependencies

2. **Update Step-by-Step Path**:

   - Add new concepts to the appropriate phase
   - Include study pattern for the new concept
   - Maintain logical progression

3. **Update Examples**:

   - Replace hardcoded concept references with generic patterns
   - Ensure examples work for any concept, not just specific ones
   - Update file references to use relative paths

4. **Review Generic Sections**:

   - Ensure Content Areas section remains generic
   - Verify Project Organization doesn't hardcode specific concepts
   - Check that Contribution Guidelines apply to all concepts

5. **Document New Patterns**:
   - If new organizational patterns emerge, document them
   - Update naming conventions if needed
   - Add new requirements to relevant sections

**Rationale**: The ruleset should provide a framework that works for any Node.js concept, not just current ones. It should guide future additions without requiring major rewrites.

### Ruleset Review Checklist

When updating the ruleset, verify:

- [ ] No hardcoded references to specific concepts (except as examples)
- [ ] Learning path remains flexible and extensible
- [ ] Cross-referencing requirements are clearly documented
- [ ] Fundamentals documentation structure is explained
- [ ] All examples use generic patterns
- [ ] New concepts can be added without breaking existing structure
- [ ] Documentation standards apply universally
- [ ] Code standards are concept-agnostic

---

## Questions or Issues?

If you have questions about these rules or encounter issues:

1. **First**: Re-read the relevant section of this ruleset
2. Review existing examples in the project
3. Check documentation in `docs/` folder
4. Refer to Node.js official documentation
5. Follow the established patterns

**Remember**:

- This ruleset is the authoritative guide - when in doubt, follow the ruleset
- The goal is to create a comprehensive, educational resource that helps developers understand Node.js deeply
- Consistency and clarity are key
- **Always follow the ruleset - it exists to ensure quality and consistency**
